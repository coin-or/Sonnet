<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sonnet</name>
    </assembly>
    <members>
        <member name="T:Sonnet.WarmStart">
            <summary>
            The class WarmStart can be used to warm-start another optimization.
            The WarmStart object should be taken from the solver (GetWarmStart) just after a Solve(),
            and applied to the solver (SetWarmStart) before another solve.
            Use via solver.GetWarmStart() and solver.SetWarmStart().
            The model at the solver that called GetWarmStart should not be significantly different from 
            the model at the solver of the subsequent SetWarmStart.
            </summary>
        </member>
        <member name="M:Sonnet.WarmStart.Dispose">
            <summary>
            Releases all resources used by the WarmStart.
            </summary>
        </member>
        <member name="M:Sonnet.WarmStart.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the WarmStart
            and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Sonnet.WarmStart.Finalize">
            <summary>
            Use C# destructor syntax for finalization code.
            </summary>
        </member>
        <member name="T:Sonnet.Named">
            <summary>
            The class Named is a base class for entities that have a Name and 
            are Compared using an integer ID. 
            The ID must be set within the derived constructor.
            </summary>
        </member>
        <member name="M:Sonnet.Named.#ctor(System.String)">
            <summary>
            Constructor of a new Named object with the given name.
            Empty string is used if no name is provided.
            </summary>
            <param name="name">The name is the new object, or empty string is not provided.</param>
        </member>
        <member name="M:Sonnet.Named.Equals(System.Object)">
            <summary>
            Compares this object to the given object and returns true iff the objects are of the same type, and have the same ID.
            </summary>
            <param name="obj">The object to compare this to.</param>
            <returns>True iff the objects are of the same type, and have the same ID.</returns>
        </member>
        <member name="M:Sonnet.Named.GetHashCode">
            <summary>
            Returns the ID of this object as hash code.
            </summary>
            <returns>A hash code (ID) for the current object.</returns>
        </member>
        <member name="M:Sonnet.Named.Equals(Sonnet.Named)">
            <summary>
            Compares this object to the given object and returns true iff the objects are of the same type, and have the same ID.
            </summary>
            <param name="obj">The object to compare this to.</param>
            <returns>True iff the objects are of the same type, and have the same ID.</returns>
        </member>
        <member name="M:Sonnet.Named.CompareTo(Sonnet.Named)">
            <summary>
            Compares the ID of this object to the ID of the given object.
            </summary>
            <param name="obj">The object to compare this to.</param>
            <returns>The int.CompareTo value.</returns>
        </member>
        <member name="P:Sonnet.Named.Name">
            <summary>
            Gets or sets the name of this object.
            Name must be not-null.
            </summary>
        </member>
        <member name="P:Sonnet.Named.ID">
            <summary>
            Returns the ID of this object.
            </summary>
        </member>
        <member name="T:Sonnet.ModelEntity">
            <summary>
            The class ModelEntity is a base class for entities that are registered with solvers.
            </summary>
        </member>
        <member name="M:Sonnet.ModelEntity.#ctor(System.String)">
            <summary>
            Constructs a new ModelEntity with the given name.
            </summary>
            <param name="name">The name of this entity.</param>
        </member>
        <member name="M:Sonnet.ModelEntity.Register(Sonnet.Solver)">
            <summary>
            Register the given solver with this entity.
            Whenever changes are made to this entity, these will be passed on to registerd solvers,
            such that the COIN solver can be updated.
            Therefore, only Generated entities (passed to the COIN solver) need to be registered.
            </summary>
            <param name="solver">The solver of which this constraint is part.</param>
        </member>
        <member name="M:Sonnet.ModelEntity.Unregister(Sonnet.Solver)">
            <summary>
            Remove the given solver from the list of registered solvers.
            If the solver was not registered, an exception will be thrown.
            </summary>
            <param name="solver">The solver</param>
        </member>
        <member name="M:Sonnet.ModelEntity.IsRegistered(Sonnet.Solver)">
            <summary>
            Returns true iff the given solver is registered with this entity.
            </summary>
            <param name="solver">The solver</param>
            <returns>True iff the given solver is registered with this entity.</returns>
        </member>
        <member name="M:Sonnet.ModelEntity.Assign(Sonnet.Solver,System.Int32)">
            <summary>
            Set the given solver to be the assigned solver, where this entity has the given offset.
            </summary>
            <param name="solver">The newly assigned solver.</param>
            <param name="offset">The offset of the current entity in the solver.</param>
        </member>
        <member name="M:Sonnet.ModelEntity.AssignedTo(Sonnet.Solver)">
            <summary>
            Determines whether the given solver is the current Assigned solver.
            </summary>
            <param name="solver">The solver to compare.</param>
            <returns>True iff the given solver is the same as the current solver.</returns>
        </member>
        <member name="F:Sonnet.ModelEntity.solvers">
            <summary>
            The list of solvers with which this entity is registered.
            Derived classes use this to notify solvers of any changes to them (name, bounds, etc)
            </summary>
        </member>
        <member name="P:Sonnet.ModelEntity.Offset">
            <summary>
            Gets the offset of this entity in the assigned solver.
            </summary>
        </member>
        <member name="P:Sonnet.ModelEntity.AssignedSolver">
            <summary>
            Gets the currently assigned solver.
            </summary>
        </member>
        <member name="P:Sonnet.ModelEntity.Assigned">
            <summary>
            Determines whether this entity is assigned to a solver.
            </summary>
        </member>
        <member name="T:Sonnet.SonnetException">
            <summary>
            The SonnetException is thrown whenever a Sonnet-specific error occurs. It is derived from ApplicationException.
            </summary>
        </member>
        <member name="M:Sonnet.SonnetException.#ctor">
            <summary>
            Initializes a new instance of the Sonnet.SonnetException class.
            </summary>
        </member>
        <member name="M:Sonnet.SonnetException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Sonnet.SonnetException class with
            a specified error message.
            </summary>
            <param name="message">A message that describes the error.</param>
        </member>
        <member name="M:Sonnet.SonnetException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the Sonnet.SonnetException class with
            a specified error message and a reference to the inner exception that is
            the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the innerException
            parameter is not a null reference, the current exception is raised in a catch
            block that handles the inner exception.</param>
        </member>
        <member name="T:Sonnet.VariableType">
            <summary>
            Specifies the types of variables: Continuous and Integer.
            </summary>
        </member>
        <member name="F:Sonnet.VariableType.Continuous">
            <summary>
            Continuous values
            </summary>
        </member>
        <member name="F:Sonnet.VariableType.Integer">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="T:Sonnet.Variable">
            <summary>
            The Variable class represents variables in expressions which 
            are use in objectives and constraints.
            Each variable has a name, lower bound and upper bound.
            In addition, each variable can take either continuous or integer values. This is
            specified as the Type of the variable.
            Variables are not explicitly added to models. The variables used within a model are
            defined by the constraints and objective of a model.
            New values for properties (Lower, Upper, etc) are automatically updated across all solvers that use this variable.
            </summary>
        </member>
        <member name="M:Sonnet.Variable.#ctor(Sonnet.VariableType)">
            <summary>
            Initializes a new instance of the Variable class of the given type, with a default name,
            lower bound of 0 and upper bound of +inf.
            </summary>
            <param name="type">The type of the new variable.</param>
        </member>
        <member name="M:Sonnet.Variable.#ctor(System.Double,System.Double,Sonnet.VariableType)">
            <summary>
            Initializes a new instance of the Variable class of the given type, with a default name,
            and which can take continuous values between the given lower and upper bounds.
            </summary>
            <param name="lower">The lower bound of the new variable.</param>
            <param name="upper">The upper bound of the new variable.</param>
            <param name="type">The type of the new variable.</param>
        </member>
        <member name="M:Sonnet.Variable.#ctor(System.String,Sonnet.VariableType)">
            <summary>
            Initializes a new instance of the Variable class of the given type, with the given name,
            lower bound of 0 and upper bound of +inf.
            </summary>
            <param name="name">The name of this variable.</param>
            <param name="type">The type of this variable.</param>
        </member>
        <member name="M:Sonnet.Variable.#ctor(System.String,System.Double,System.Double,Sonnet.VariableType)">
            <summary>
            Initializes a new instance of the Variable class of the given type, with the given name,
            and which can take values between the given lower and upper bounds.
            </summary>
            <param name="name">The name of the new variable.</param>
            <param name="lower">The lower bound of the new variable.</param>
            <param name="upper">The upper bound of the new variable.</param>
            <param name="type">The type of the new variable.</param>
        </member>
        <member name="M:Sonnet.Variable.New(System.Int32,System.String,System.Double,System.Double,Sonnet.VariableType)">
            <summary>
            Returns an array of the given size filled with new Variables constructed with a name,
            lower bound, upper bound and of the given type.
            About names: If a name is given, then this will be used as the main part of the name is the variables.
            For example, given name 'x', the variables will be named 'x[0]', 'x[1]', etc.
            If no name is given, then the default names are used.
            </summary>
            <param name="size">The number of new variables.</param>
            <param name="varname">The base part of the name of the new variables.</param>
            <param name="lower">The lower bound of the new variables.</param>
            <param name="upper">The upper bound of the new variables.</param>
            <param name="type">The type of the new variables.</param>
            <returns>Array of variables of the given size.</returns>
        </member>
        <member name="M:Sonnet.Variable.New``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Double,System.Double,Sonnet.VariableType)">
            <summary>
            Returns a dictionary of the given type filled with new Variables constructed with a name,
            lower bound, upper bound and of the given type.
            Example: var x = Variable.New&lt;Product&gt;(MyListOfProducts, "x");
            About names: If a name is given, then this will be used as the main part of the name is the variables.
            For example, given name 'x', the variables will be named 'x[0]', 'x[1]', etc.
            If no name is given, then the default names are used.
            </summary>
            <typeparam name="T">Type of elements of the set (eg string)</typeparam>
            <param name="set">The set for which to create a variable for each element.</param>
            <param name="varname">The base part of the name of the new variables.</param>
            <param name="lower">The lower bound of the new variables.</param>
            <param name="upper">The upper bound of the new variables.</param>
            <param name="type">The type of the new variables.</param>
            <returns>Array of variables of the given size.</returns>
        </member>
        <member name="M:Sonnet.Variable.New``1(System.String,System.Double,System.Double,Sonnet.VariableType)">
            <summary>
            Returns a dictionary of the given type filled with new Variables constructed with a name,
            lower bound, upper bound and of the given type. 
            The type T must be an enum.
            About names: If a name is given, then this will be used as the main part of the name is the variables.
            For example, given name 'x', the variables will be named 'x[0]', 'x[1]', etc.
            If no name is given, then the default names are used.
            </summary>
            <typeparam name="T">Enum type of elements of the set.</typeparam>
            <param name="varname">The base part of the name of the new variables.</param>
            <param name="lower">The lower bound of the new variables.</param>
            <param name="upper">The upper bound of the new variables.</param>
            <param name="type">The type of the new variables.</param>
            <returns>Array of variables of the given size.</returns>
        </member>
        <member name="M:Sonnet.Variable.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">The System.Object to compare with the current variable.</param>
            <returns>true if obj has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:Sonnet.Variable.GetHashCode">
            <summary>
            Serves as a hash function for this variable, based only on the id.
            </summary>
            <returns>A hash code for the current variable.</returns>
        </member>
        <member name="M:Sonnet.Variable.ToString">
            <summary>
            Returns a string that represents the current variable.
            The string is built up like
            {0} : {1} : [{2}, {3}]
            where {0} is the Name, {1} is the Type, 
            {2} is the lower bound and {3} is the upper bound
            </summary>
            <returns>A string that represents the current variable.</returns>
        </member>
        <member name="M:Sonnet.Variable.ToLevelString">
            <summary>
            Returns a string that represent the current variable, together with its value 
            and reduced cost:
            {0} = {1}   ( {2} )
            where {0} is the normal string representation,
            {1} is the current value, and
            {2} is the reduced cost.
            </summary>
            <returns>A string representation of this instance using its value and reduced cost.</returns>
        </member>
        <member name="M:Sonnet.Variable.Freeze">
            <summary>
            Freeze the current value of this variable.
            In effect, the lower and upper bounds are both set to the current value.
            </summary>
            <returns>True if this variable was not yet frozen beforem, and false otherwise.</returns>
        </member>
        <member name="M:Sonnet.Variable.UnFreeze">
            <summary>
            Attempt to unfreeze this variable.
            If Freeze() is called multiple times, then UnFreeze() must be called at least as many times.
            Only at the last call is the variable value unfrozen.
            </summary>
            <returns>True if the variable value was unfrozen; false otherwise.</returns>
        </member>
        <member name="M:Sonnet.Variable.IsFeasible">
            <summary>
            Test whether the current value of this variable is within the bounds and is integer if applicable.
            </summary>
            <returns>True iff bounds and type are satisfied.</returns>
        </member>
        <member name="M:Sonnet.Variable.Assign(Sonnet.Solver,System.Int32,System.Double,System.Double)">
            <summary>
            Assigns the current solution of the given solver to this variable.
            This includes the given offset, the value and reduced cost.
            A variable can be assigned to at most one solver at a time.
            This method is called after the solver finished solving.
            </summary>
            <param name="solver">The solver to be assigned</param>
            <param name="offset">The offset of this variable in the array of variables of the solver.</param>
            <param name="value">The value of this variable in the current solution.</param>
            <param name="reducedCost">The reduced cost of this variable in the current solution.</param>
        </member>
        <member name="M:Sonnet.Variable.op_LessThanOrEqual(System.Double,Sonnet.Variable)">
            <summary>
            Creates a new constraint "c &lt;= x"
            </summary>
            <param name="c">The constant.</param>
            <param name="x">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_LessThanOrEqual(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new constraint "x &lt;= c"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_LessThanOrEqual(Sonnet.Variable,Sonnet.Variable)">
            <summary>
            Creates a new constraint "x &lt;= y"
            </summary>
            <param name="x">The left-hand side variable.</param>
            <param name="y">The right-hand side variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_GreaterThanOrEqual(System.Double,Sonnet.Variable)">
            <summary>
            Creates a new constraint "c &gt;= x"
            </summary>
            <param name="c">The constant.</param>
            <param name="x">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_GreaterThanOrEqual(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new constraint "x &gt;= c"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_GreaterThanOrEqual(Sonnet.Variable,Sonnet.Variable)">
            <summary>
            Creates a new constraint "x &gt;= y"
            </summary>
            <param name="x">The variable.</param>
            <param name="y">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Equality(System.Double,Sonnet.Variable)">
            <summary>
            Creates a new constraint "c == x"
            </summary>
            <param name="c">The constant.</param>
            <param name="x">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Inequality(System.Double,Sonnet.Variable)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="c">The constant.</param>
            <param name="x">The variable.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Equality(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new constraint "x == c"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Inequality(Sonnet.Variable,System.Double)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Equality(Sonnet.Variable,Sonnet.Variable)">
            <summary>
            Creates a new constraint "x == y"
            </summary>
            <param name="x">The variable.</param>
            <param name="y">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Inequality(Sonnet.Variable,Sonnet.Variable)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="x">The variable.</param>
            <param name="y">The variable.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Addition(System.Double,Sonnet.Variable)">
            <summary>
            Creates a new expression "c + x"
            </summary>
            <param name="c">The constrant.</param>
            <param name="x">The variable.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Addition(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new expression "x + c"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Addition(Sonnet.Variable,Sonnet.Variable)">
            <summary>
            Creates a new expression "x + y"
            </summary>
            <param name="x">The variable.</param>
            <param name="y">The variable.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Subtraction(System.Double,Sonnet.Variable)">
            <summary>
            Creates a new expression "c - x"
            </summary>
            <param name="c">The constant.</param>
            <param name="x">The variable.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Subtraction(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new expression "x - c"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Subtraction(Sonnet.Variable,Sonnet.Variable)">
            <summary>
            Creates a new expression "x - y"
            </summary>
            <param name="x">The variable.</param>
            <param name="y">The variable.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Multiply(System.Double,Sonnet.Variable)">
            <summary>
            Creates a new expression "c * x"
            </summary>
            <param name="c">The constant.</param>
            <param name="x">The variable.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Multiply(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new expression "c * x"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Variable.op_Division(Sonnet.Variable,System.Double)">
            <summary>
            Creates a new expression "(1/c) * x"
            </summary>
            <param name="x">The variable.</param>
            <param name="c">The constant.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="F:Sonnet.Variable.numberOfVariables">
            <summary>
            Counts the global number of variables. Mainly used for id.
            </summary>
        </member>
        <member name="F:Sonnet.Variable.upper">
            <summary>
            The upper bound value.
            </summary>
        </member>
        <member name="F:Sonnet.Variable.lower">
            <summary>
            The lower bound value.
            </summary>
        </member>
        <member name="F:Sonnet.Variable.type">
            <summary>
            The type of the current variable.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.Upper">
            <summary>
            Get or set the upper bound of this variable.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.Lower">
            <summary>
            Get or set the lower bound value for this variable.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.Type">
            <summary>
            Get or set the type (Continuous, Integer) of this variable.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.Name">
            <summary>
            Get or set the name of this constraint.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.IsFrozen">
            <summary>
            Return whether the value of this variable is frozen.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.Value">
            <summary>
            Get or set the value of this variable in the current solution.
            </summary>
        </member>
        <member name="P:Sonnet.Variable.ReducedCost">
            <summary>
            Get the reduced cost of this variable in the current solution.
            </summary>
        </member>
        <member name="T:Sonnet.MathUtils">
            <summary>
            This class implements various static methods
            </summary>
        </member>
        <member name="M:Sonnet.MathUtils.CompareToEps(System.Double,System.Double)">
            <summary>
            Compares this double to the given value.
            Returns -1 if b is larger, 1 if b is smaller, and 0 otherwise.
            This method uses Utils.Epsilon.
            </summary>
            <param name="a">This double.</param>
            <param name="b">The given double.</param>
            <returns>-1 if this double is smaller than b - eps,
            1 if a is larget than b + eps, and 0 otherwise.
            </returns>
        </member>
        <member name="M:Sonnet.MathUtils.IsPositive(System.Double)">
            <summary>
            Determines whether this double is positive.
            This method uses Utils.Epsilon.
            </summary>
            <param name="a">This double</param>
            <returns>True iff this double is larger than zero.</returns>
        </member>
        <member name="M:Sonnet.MathUtils.IsNegative(System.Double)">
            <summary>
            Determines whether this double is negative.
            This method uses Utils.Epsilon.
            </summary>
            <param name="a">This double</param>
            <returns>True iff this double is smaller than zero.</returns>
        </member>
        <member name="M:Sonnet.MathUtils.IsBetween(System.Double,System.Double,System.Double)">
            <summary>
            Determines whether this double is equal to or between the given two bounds.
            This method uses Utils.Epsilon.
            </summary>
            <param name="x">This double.</param>
            <param name="l">the lowwer bound.</param>
            <param name="u">The upper bound.</param>
            <returns>True iff this double is equal to or between the two bounds.</returns>
        </member>
        <member name="M:Sonnet.MathUtils.IsZero(System.Double)">
            <summary>
            Determines whether this double is equal to zero.
            This method uses Utils.Epsilon.
            </summary>
            <param name="a">This double.</param>
            <returns>True iff this double is equal to zero.</returns>
        </member>
        <member name="M:Sonnet.MathUtils.IsInteger(System.Double)">
            <summary>
            Determines whether this double is integer.
            This method uses Utils.Epsilon.
            </summary>
            <param name="a">This double</param>
            <returns>true if this double is integer, and false otherwise.</returns>
        </member>
        <member name="M:Sonnet.MathUtils.ToDoubleString(System.Double)">
            <summary>
            Creates a string representation of this double.
            Uses "-Inf" and "Inf" whenever applicatable.
            </summary>
            <param name="a">This double.</param>
            <returns>"-Inf" if a is less than or equal to Utils.Infinity, "Inf" is larger or equal, and 
            regular a.ToString() otherwise.</returns>
        </member>
        <member name="T:Sonnet.Utils">
            <summary>
            This static class contains extension methods.
            </summary>
        </member>
        <member name="M:Sonnet.Utils.GetVariable(System.Collections.Generic.IEnumerable{Sonnet.Variable},System.String)">
            <summary>
            Returns the first variable from the enumerable for which the Name strign Equals the given name. 
            This is case sensitive.
            </summary>
            <param name="variables">The variables to search.</param>
            <param name="name">The name of the variable to look for.</param>
            <returns>The first variable from the enumerable for which the Name strign Equals the given name.</returns>
        </member>
        <member name="M:Sonnet.Utils.GetCbcSolverArgs(COIN.OsiCbcSolverInterface)">
            <summary>
            Returns the array of arguments to be used when solving using an instance of OsiCbcSolverInterface.
            Returns an empty array if no arguments were found.
            See also Sonnet.Solve(..)
            </summary>
            <param name="solver">The OsiCbcSolverInterface instance.</param>
            <returns>The arguments for CbcMain1(..).</returns>
        </member>
        <member name="M:Sonnet.Utils.SetCbcSolverArgs(COIN.OsiCbcSolverInterface,System.String[])">
            <summary>
            Sets the array of arguments to be used when solving using an instance of OsiCbcSolverInterface.
            See also Sonnet.Solve(..)
            </summary>
            <param name="solver">The OsiCbcSolverInterface instance.</param>
            <param name="args">The arguments for CbcMain1(..).</param>
        </member>
        <member name="M:Sonnet.InternalUtils.UseBranchAndBound(COIN.OsiCbcSolverInterface)">
            <summary>
            Returns true iff exactly one argument is set for this solver using SetCbcMainArgs, 
            and that argument is "-branchAndBound".
            </summary>
            <param name="solver"></param>
            <returns></returns>
        </member>
        <member name="T:Sonnet.Ensure">
            <summary>
            The Ensure class contains various tests that will throw an exception if a condition is not met.
            For example:
                Ensure.IsTrue(a == 5);
            </summary>
        </member>
        <member name="M:Sonnet.Ensure.IsTrue(System.Boolean)">
            <summary>
            Throws an ArgumentException if b is not true.
            </summary>
            <param name="b">The boolean value to be tested.</param>
        </member>
        <member name="M:Sonnet.Ensure.IsFalse(System.Boolean)">
            <summary>
            Throws an ArgumentException if b is not false.
            </summary>
            <param name="b">The boolean value to be tested.</param>
        </member>
        <member name="M:Sonnet.Ensure.Is``1(System.Type,System.String)">
            <summary>
            Throws and ArgumentOutOfRangeException is the given type is not derived from the generic type.
            Uses derived.IsSubclassOf.
            </summary>
            <typeparam name="Base">The base type</typeparam>
            <param name="derived">The derived type</param>
            <param name="paramName">The given parameter name to be reported.</param>
        </member>
        <member name="M:Sonnet.Ensure.Equals``1(System.IEquatable{``0},System.IEquatable{``0})">
            <summary>
            Throws an ArgumentException if a and b are not equal.
            </summary>
            <typeparam name="T">The type of objects.</typeparam>
            <param name="a">The object to compare.</param>
            <param name="b">The object to compare to.</param>
        </member>
        <member name="M:Sonnet.Ensure.NotNull(System.Object,System.String)">
            <summary>
            Throws an ArgumentNullException if the object is null.
            </summary>
            <param name="obj">The given object.</param>
            <param name="paramName">The given parameter name to be reported.</param>
        </member>
        <member name="M:Sonnet.Ensure.NotNullOrWhiteSpace(System.String,System.String)">
            <summary>
            Throws an ArgumentNullException for the given parameter name if the object is null or only spaces.
            </summary>
            <param name="value">The given string value.</param>
            <param name="paramName">The given parameter name to be reported.</param>
        </member>
        <member name="T:Sonnet.Solver">
            <summary>
            The Solver class is responsible of optimizing the problems represented by a Model.
            This class is the main link back to the COIN Osi solvers (OsiSolverInterface) through the SonnetWrapper.
            The Solver can only be constructed for a given type of OsiSolverInterface, or for 
            a specific instance derived from OsiSolverInterface. 
            The OsiSolver can be retrieved using the OsiSolver proporty.
            The available classes in SonnetWrapper that derive from OsiSolverInterface can be retrieved using Solver.GetSolverTypes().
            Ideally, the model is built before creating the Solver. Changes after the construction of the solver involve more overhead.
            Before the model is given to the OsiSolver, it will be Generated automatically (or explicitly). At this point, the
            constraints of the model are transformed into the constraint matrix that is loaded into the OsiSolver.
            </summary>
        </member>
        <member name="M:Sonnet.Solver.#ctor(Sonnet.Model,COIN.OsiSolverInterface,System.String)">
            <summary>
            Initializes a new instance of the Solver class with the given name and model, 
            and using the given instance derived from OsiSolverInterface.
            </summary>
            <param name="model">The model used in this solver.</param>
            <param name="solver">The instance of an OsiSolver, eg, OsiClpSolverInterface to be used.</param>
            <param name="name">The name for this solver.</param>
        </member>
        <member name="M:Sonnet.Solver.#ctor(Sonnet.Model,System.Type,System.String)">
            <summary>
            Initializes a new instance of the Solver class with the given name and model,
            and using a to be constructed instance of the given type derived from OsiSolverInterface.
            </summary>
            <param name="model">The model used in this solver.</param>
            <param name="osiSolverInterfaceType">The type derived from OsiSolverInterface to be used.</param>
            <param name="name">The name for this solver.</param>
        </member>
        <member name="M:Sonnet.Solver.New``1(Sonnet.Model,System.String)">
            <summary>
            Initializes a new instance of the Solver class with the given name and model,
            for using a to be constructed instance of the given type derived from OsiSolverInterface.
            </summary>
            <typeparam name="T">The type of OsiSolver to be used, derived from OsiSolverInterface.</typeparam>
            <param name="model">The model used in this solver.</param>
            <param name="name">The name for this solver.</param>
            <returns>The new instance of the Solver class.</returns>
        </member>
        <member name="M:Sonnet.Solver.GetOsiSolverTypes">
            <summary>
            Return all types that are derived from OsiSolverInterface in the SonnetWrapper.
            </summary>
            <returns>An array of Types within the SonnetWrapper that are derived from OsiSolverInterface.</returns>
        </member>
        <member name="M:Sonnet.Solver.Add(Sonnet.Constraint)">
            <summary>
            Adds (a reference) the given constraint to the model
            </summary>
            <param name="con">The constraint to add to the model.</param>
        </member>
        <member name="M:Sonnet.Solver.Maximise(System.Boolean)">
            <summary>
             Maximises the model.
             This implicitly sets the objective sense to Maximise.
             The method uses branch and bound if model is MIP and LP otherwise.
             </summary>
             <param name="forceRelaxation">Force solving of the LP relaxation</param>
        </member>
        <member name="M:Sonnet.Solver.Minimise(System.Boolean)">
            <summary>
             Minimises the model.
             This implicitly sets the objective sense to Minimise.
             The method uses branch and bound if model is MIP and LP otherwise.
             </summary>
             <param name="forceRelaxation">Force solving of the LP relaxation.</param>
        </member>
        <member name="M:Sonnet.Solver.Solve(System.Boolean)">
            <summary>
            Solve the model according to the ObjectiveSense settings.
            The method uses branch and bound if model is MIP and LP otherwise.
            </summary>
            <param name="forceRelaxation">Force solving of the LP relaxation.</param>
        </member>
        <member name="M:Sonnet.Solver.Resolve(System.Boolean)">
            <summary>
            Resolve the model according to the ObjectiveSense settings.
            The method uses branch and bound if model is MIP and LP otherwise.
            </summary>
            <param name="forceRelaxation">Force solving of the LP relaxation.</param>
        </member>
        <member name="M:Sonnet.Solver.IsFeasible">
            <summary>
            Determine whether the current solution satisfies all constraints and variables bounds and types.
            </summary>
            <returns>True iff the current solution is feasible.</returns>
        </member>
        <member name="M:Sonnet.Solver.GetWarmStart">
            <summary>
             Gets the warm start object for the current problem
            </summary>
        </member>
        <member name="M:Sonnet.Solver.GetEmptyWarmStart">
            <summary>
             Gets an empty warm start object for the current problem
            </summary>
        </member>
        <member name="M:Sonnet.Solver.SetWarmStart(Sonnet.WarmStart)">
            <summary>
             Set (apply) the given warm start object to the current problem
            </summary>
        </member>
        <member name="M:Sonnet.Solver.ResetAfterMIPSolve">
            <summary>
            Reset the bounds etc after a MIP solve (branch and bound).
            This is done automatically according to the AutoResetMIPSolve property.
            Note that this also reselt the results of solver.get.. functions.
            </summary>
        </member>
        <member name="M:Sonnet.Solver.SaveBeforeMIPSolve">
            <summary>
            Save the bounds etc before a MIP solve (branch and bound)
            This is done automatically according to the AutoResetMIPSolve property.
            </summary>
        </member>
        <member name="M:Sonnet.Solver.Generate(Sonnet.Constraint)">
            <summary>
            Generate the given constraint, assuming it hasnt been generated before.
            If the model has _not_ been generated (yet), the constraint is not loaded into the solver here. Instead, this is done in bulk in ::Generate()
            If the model has been generated, the constraint is added into the solver here.
            </summary>
            <param name="con">The constraint to generate.</param>
        </member>
        <member name="M:Sonnet.Solver.Generate(Sonnet.Objective)">
            <summary>
            Generate the given objective: Assemble the objective and register it to be part of this model. Also assign is to this model for quick reference.
            Then generate its (new) variables.
            If the model has _not_ been generated (yet), the objective is not loaded into the solver here. Instead, this is done in bulk in ::Generate()
            If the model has been generated, the constraint is added into the solver here.
            </summary>
            <param name="obj">The objective to generate.</param>
        </member>
        <member name="M:Sonnet.Solver.Generate">
            <summary>
             Generates (builds) the model to be solved. 
             This can be called explicitly, but is done automatically within a solve.
            </summary>
        </member>
        <member name="M:Sonnet.Solver.UnGenerate">
            <summary>
            Ungenerate the model.
            </summary>
        </member>
        <member name="M:Sonnet.Solver.Export(System.String)">
            <summary>
            Exports the model in either MPS, LP or SONNET format, depending on the extension of the given filename
            Note, after solving a model, the Bounds etc could be left at non-original values!
            If you want to export the original bounds etc, then call Generate() before Exporting.
            </summary>
            <param name="filename">The full file name to be used to export the model.</param>
        </member>
        <member name="M:Sonnet.Solver.ToString">
            <summary>
            Returns a string that represents the current solver.
            Similar to model.ToString().
            </summary>
            <returns>String representation of the current solver and model.</returns>
        </member>
        <member name="M:Sonnet.Solver.ToSolutionString">
            <summary>
            Returns a string that represents the current solution of this solver.
            </summary>
            <returns>String representation of the current solution.</returns>
        </member>
        <member name="M:Sonnet.Solver.ToStatisticsString">
            <summary>
            Returns a string the contains statitics for the current model and solver.
            This includes number of variables, constraints, etc.
            </summary>
            <returns>String representation of statistics of the current solver.</returns>
        </member>
        <member name="M:Sonnet.Solver.IsRegistered(Sonnet.Objective)">
            <summary>
            Determine whether the given objective was registered 
            </summary>
            <param name="obj">The objective</param>
            <returns>True iff the given objective equals the current objective.</returns>
        </member>
        <member name="M:Sonnet.Solver.IsRegistered(Sonnet.Constraint)">
            <summary>
            For Testing only: Is this Constraint registered? Only generated constraints are generated?
            Not-yet generated constraints are not registered, since changes in the constraints do not need to be passed
            into the COIN solver yet.
            </summary>
            <param name="c">The constraint.</param>
            <returns>True iff one of the constraints Equals the given constraint.</returns>
        </member>
        <member name="M:Sonnet.Solver.Contains(Sonnet.Constraint)">
            <summary>
            For Testing only: IsRegistered OR in the (to-be) added list
            </summary>
            <param name="c">The constraint.</param>
            <returns>True iff the given constraint is registered, or Equals one of the raw constraints (not yet generated).</returns>
        </member>
        <member name="M:Sonnet.Solver.Offset(Sonnet.Constraint)">
            <summary>
            Get the element index (offset) of the constraint in this model. An exception is thrown if no offset found.
            </summary>
            <param name="con">The constraint.</param>
            <returns>The integer offset of the given constraint in the current solver.</returns>
        </member>
        <member name="M:Sonnet.Solver.Offset(Sonnet.Variable)">
            <summary>
            Get the element index (offset) of the variable in this model
            </summary>
            <param name="var">The variable.</param>
            <returns>The integer offset of the given variable in the current solver.</returns>
        </member>
        <member name="M:Sonnet.Solver.GetConstraint(System.String)">
            <summary>
            Return the constraint, given its name in this model
            </summary>
            <param name="name">The name of the constraint to get.</param>
            <returns>The first constraint with Name that Equals the given name, or null if not found.</returns>
        </member>
        <member name="M:Sonnet.Solver.GetVariable(System.String)">
            <summary>
            return the variable, given its element index in this model
            </summary>
            <param name="name">The name of the variable to get.</param>
            <returns>The first variable with Name that Equals the given name, or null if not found.</returns>
        </member>
        <member name="M:Sonnet.Solver.Value(Sonnet.Variable)">
            <summary>
            Deprecated: use property of Variable
            Looks up the offset, and retrieves value.
            </summary>
            <param name="v">The variable to return the value for.</param>
            <returns>The value of the variable in the current solution at the solver.</returns>
        </member>
        <member name="M:Sonnet.Solver.ReducedCost(Sonnet.Variable)">
            <summary>
            Deprecated: use property of Variable
            Looks up the offset, and retrieves the reduced cost.
            </summary>
            <param name="v">The variable to return the reduced cost for.</param>
            <returns>The reduced cost of the variable in the current solution at the solver.</returns>
        </member>
        <member name="M:Sonnet.Solver.Price(Sonnet.Constraint)">
            <summary>
            Deprecated: Use property of Constraint.
            Looks up the offset, and retreives the price.
            </summary>
            <param name="c">The constraint to return the price for.</param>
            <returns>The price of the given constraint in the current solution at the solver.</returns>
        </member>
        <member name="M:Sonnet.Solver.AssignSolution(System.Boolean)">
            <summary>
            Get and store the solution status (optimal, etc), and the solution values for the variables and constraints from the solver.
            These values are subsequently stored at the variables and constraints for later retrieval via variable.Value etc.
            Some values, like row prices, are not available for MIP.
            </summary>
            <param name="mipSolve">Latest solve was mip solve</param>
        </member>
        <member name="M:Sonnet.Solver.AssignSolutionStatus(System.Boolean)">
            <summary>
            Get and store the solution status values (isProvenOptimal etc)
            Iteration Count is not available for MIP.
            </summary>
            <param name="mipSolve">Latest solve was mip solve</param>
        </member>
        <member name="M:Sonnet.Solver.AssignVariableSolution(System.Boolean)">
            <summary>
            Get and store the primal solution values to the variables and reduced cost
            Reduced Cost of columns not available for MIP.
            /// </summary>
            <param name="mipSolve">Latest solve was mip solve</param>
        </member>
        <member name="M:Sonnet.Solver.AssignConstraintSolution(System.Boolean)">
            <summary>
            get and store the values of the primal constraints in the dual solution
            get and propagate the values of the primal constraints in the dual solution
            and the total LHS( or "middle") value of the constraints in the current (primal) solution, with all var. moved left
            Prices or rows not available for MIP.
            </summary>
            <param name="mipSolve">Latest solve was mip solve</param>
        </member>
        <member name="M:Sonnet.Solver.SetVariableName(Sonnet.Variable,System.String)">
            <summary>
            Set the name of the given variable within the solver (only) 
            </summary>
            <param name="var">The variable to set the name for.</param>
            <param name="name">The new name to set for this variable within the solver.</param>
        </member>
        <member name="M:Sonnet.Solver.SetObjectiveCoefficient(Sonnet.Variable,System.Double)">
            <summary>
            methods for changing the objective function
            </summary>
            <param name="var">The variable to set the objective coefficient for.</param>
            <param name="value">The new coefficient to set for this variable within the solver.</param>
        </member>
        <member name="M:Sonnet.Solver.Dispose">
            <summary>
            Implement IDisposable.
            Do not make this method virtual.
            A derived class should not be able to override this method.
            </summary>
        </member>
        <member name="M:Sonnet.Solver.Dispose(System.Boolean)">
            <summary>
            Dispose(bool disposing) executes in two distinct scenarios.
            If disposing equals true, the method has been called directly
            or indirectly by a user's code. Managed and unmanaged resources
            can be disposed.
            If disposing equals false, the method has been called by the
            runtime from inside the finalizer and you should not reference
            other objects. Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing">Whether this method has been called by user's code.</param>
        </member>
        <member name="M:Sonnet.Solver.Finalize">
            <summary>
            Use C# destructor syntax for finalization code.
            This destructor will run only if the Dispose method
            does not get called.
            It gives your base class the opportunity to finalize.
            Do not provide destructors in types derived from this class.
            </summary>
        </member>
        <member name="P:Sonnet.Solver.LogLevel">
            <summary>
            Gets or sets the amount of logging for the current solver
            </summary>
        </member>
        <member name="P:Sonnet.Solver.AutoResetMIPSolve">
            <summary>
            When true, automatically reset the solver after a MIP has been solved (= Default)
            When false, you have to manually Save before and Reset after a MIP solve.
            Note, this only affects MIP.
            </summary>
        </member>
        <member name="P:Sonnet.Solver.NameDiscipline">
            <summary>
            The name discipline; specifies how the solver will handle row and
             column names.
            - 0: Auto names: Names cannot be set by the client. Names of the form
            Rnnnnnnn or Cnnnnnnn are generated on demand when a name for a
            specific row or column is requested; nnnnnnn is derived from the row
            or column index. Requests for a vector of names return a vector with
            zero entries.
            - 1: Lazy names: Names supplied by the client are retained. Names of the
            form Rnnnnnnn or Cnnnnnnn are generated on demand if no name has been
            supplied by the client. Requests for a vector of names return a
            vector sized to the largest index of a name supplied by the client;
            some entries in the vector may be null strings.
            - 2: Full names: Names supplied by the client are retained. Names of the
            form Rnnnnnnn or Cnnnnnnn are generated on demand if no name has been
            supplied by the client. Requests for a vector of names return a
            vector sized to match the constraint system, and all entries will
            contain either the name specified by the client or a generated name.
            </summary>
        </member>
        <member name="P:Sonnet.Solver.Infinity">
            <summary>
            Get the Infinity of the current solver
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsMIP">
            <summary>
            Returns true iff there is at least one integer variable
            </summary>
        </member>
        <member name="P:Sonnet.Solver.Version">
            <summary>
            Gets the Version number of this assembly
            </summary>
        </member>
        <member name="P:Sonnet.Solver.Model">
            <summary>
            Get the model of the current solver
            </summary>
        </member>
        <member name="P:Sonnet.Solver.OsiSolver">
            <summary>
            Get the used OsiSolver
            </summary>
        </member>
        <member name="P:Sonnet.Solver.OsiSolverFullName">
            <summary>
            Get the full name of the type of OsiSolver.
            For example, "COIN.OsiClpSolverInterface"
            </summary>
        </member>
        <member name="P:Sonnet.Solver.Generated">
            <summary>
            Get whether this model was already generated (at least) once before.
            Note, if alterations have been made after the last solve (Generate), then still this will return true.
            </summary>
        </member>
        <member name="P:Sonnet.Solver.NumberOfConstraints">
            <summary>
            Gets the number of generated constraints.
            </summary>
        </member>
        <member name="P:Sonnet.Solver.NumberOfVariables">
            <summary>
            Gets the number of generated variables.
            </summary>
        </member>
        <member name="P:Sonnet.Solver.NumberOfElements">
            <summary>
            Gets the number of elements in the constraint matrix
            </summary>
        </member>
        <member name="P:Sonnet.Solver.NumberOfIntegerVariables">
            <summary>
            Gets the number of integer variables
            </summary>
        </member>
        <member name="P:Sonnet.Solver.Constraints">
            <summary>
            Gets the generated constraints
            </summary>
        </member>
        <member name="P:Sonnet.Solver.Variables">
            <summary>
            Gets the variables currenlty generated
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsSolving">
            <summary>
            Is the solver busy Solving?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsAbandoned">
            <summary>
            Are there numerical difficulties?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsProvenOptimal">
            <summary>
            Is optimality proven?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsProvenPrimalInfeasible">
            <summary>
            Is primal infeasiblity proven?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsProvenDualInfeasible">
            <summary>
            Is dual infeasiblity proven?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsPrimalObjectiveLimitReached">
            <summary>
            Is the given primal objective limit reached?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsDualObjectiveLimitReached">
            <summary>
            Is the given dual objective limit reached?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IsIterationLimitReached">
            <summary>
            Iteration limit reached?
            </summary>
        </member>
        <member name="P:Sonnet.Solver.IterationCount">
            <summary>
            Get the number of iterations it took to solve the (latest) problem (whatever ``iteration'' means to the solver).
            </summary>
        </member>
        <member name="T:Sonnet.ObjectiveSense">
            <summary>
            Specifies the types of objective sense: Maximise or Minimise.
            </summary>
        </member>
        <member name="F:Sonnet.ObjectiveSense.Maximise">
            <summary>
            Maximise the value of the given objective function.
            </summary>
        </member>
        <member name="F:Sonnet.ObjectiveSense.Minimise">
            <summary>
            Minimise the value of the given objective function.
            </summary>
        </member>
        <member name="T:Sonnet.Objective">
            <summary>
            The Objective class is an expression that can be assigned to one or more 
            models. 
            The expression is copied, and can not be modified, except by modifying individual coefficients.
            The Objective itself does not specify whether its value will be maximise or minimised.
            The direction of the optimisation is set at the Model.
            The constant in the given expression is taken into account.
            </summary>
        </member>
        <member name="M:Sonnet.Objective.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Objective class with the given 
            name and an empty expression. 
            </summary>
            <param name="name">The given name.</param>
        </member>
        <member name="M:Sonnet.Objective.#ctor(Sonnet.Expression)">
            <summary>
            Initializes a new instance of the Objective class
            that contains elements copied from the specified expression.
            </summary>
            <param name="expr">The expression whose elements are copied to the new objective.</param>
        </member>
        <member name="M:Sonnet.Objective.#ctor(System.String,Sonnet.Expression)">
            <summary>
            Initializes a new instance of the Objective class with the given name
            that contains elements copied from the specified expression.
            </summary>
            <param name="name">The name for the new objective.</param>
            <param name="expr">The expression whose elements are copied to the new objective.</param>
        </member>
        <member name="M:Sonnet.Objective.op_Implicit(Sonnet.Expression)~Sonnet.Objective">
            <summary>
            Implicitly initializes a new instance of the Objective class
            that contains elements copied from the specified expression.
            For example: 
            Variable x = new Variable();
            Expression expression = 2 * x;
            Objective obj = expression;
            Objective obj2 = 3 * x;
            </summary>
            <param name="expr">The expression whose elements are copied to the new objective.</param>
            <returns>The new objective.</returns>
        </member>
        <member name="M:Sonnet.Objective.op_Implicit(Sonnet.Variable)~Sonnet.Objective">
            <summary>
            Implicitly initializes a new instance of the Objective class
            that contains only the given variable.
            For example: 
            Variable x = new Variable();
            Objective obj = x;
            // Objective obj = 1.0 * x; // same thing.
            </summary>
            <param name="x">The variable that makes up the new objective.</param>
            <returns>The new objective.</returns>
        </member>
        <member name="M:Sonnet.Objective.Clear">
            <summary>
            Removes all elements from the Objective.
            </summary>
        </member>
        <member name="M:Sonnet.Objective.ToString">
            <summary>
            Converts the value of this instance to a System.String.
            </summary>
            <returns>A string representation of this instance.</returns>
        </member>
        <member name="M:Sonnet.Objective.ToLevelString">
            <summary>
            Converts the value of this instance to a System.String using the Level of the expression
            of this objective.
            </summary>
            <returns>A string representation of this instance using the Level.</returns>
        </member>
        <member name="M:Sonnet.Objective.Level">
            <summary>
            Gets the level of this objective. This should be equal to the Value.
            See Level of the Expression class.
            </summary>
            <returns>The level.</returns>
        </member>
        <member name="M:Sonnet.Objective.GetCoefficient(Sonnet.Variable)">
            <summary>
            Returns the coefficient of the given variable in this objective.
            </summary>
            <param name="var">The variable whose coefficient to return.</param>
            <returns>The coefficient of the given variable.</returns>
        </member>
        <member name="M:Sonnet.Objective.SetCoefficient(Sonnet.Variable,System.Double)">
            <summary>
            Sets the coefficients of the given variable in this objective.
            All solvers that use this objective are updated.
            </summary>
            <param name="var">The variable whose coefficient is to be set.</param>
            <param name="coef">The new coefficient.</param>
            <returns>The previous coefficients of the given variable in this objective.</returns>
        </member>
        <member name="M:Sonnet.Objective.Assemble">
            <summary>
            Assemble this objective by assembling its expression.
            </summary>
        </member>
        <member name="M:Sonnet.Objective.Assign(Sonnet.Solver,System.Double)">
            <summary>
            Assigns the given solver, and set the Value of this objective.
            </summary>
            <param name="solver">The solver to be assigned.</param>
            <param name="value">The new Value of this objective.</param>
        </member>
        <member name="M:Sonnet.Objective.GutsOfConstructor(System.String,Sonnet.Expression)">
            <summary>
            Initializes this objective.
            </summary>
            <param name="name">The name to be used for this objective.</param>
            <param name="expr">The expression to be used for this objective.</param>
        </member>
        <member name="P:Sonnet.Objective.Value">
            <summary>
            Gets the current Value of this objective.
            This value is set (AssignSolution) after the optimisation.
            </summary>
        </member>
        <member name="P:Sonnet.Objective.Coefficients">
            <summary>
            Returns the coefficients of (the expression of) this objective.
            </summary>
        </member>
        <member name="P:Sonnet.Objective.Constant">
            <summary>
            Returns the constant of (the expression of) this objective.
            </summary>
        </member>
        <member name="T:Sonnet.Model">
            <summary>
            The Model class holds the objective and a collection of constraints.
            Unlike constraints, the variables are not explicitly added to the model.
            Rather, the variables of a model are only implied by variables use within the objective and constraints.
            This is also the reason why export functionality of the model is limited.
            </summary>
        </member>
        <member name="M:Sonnet.Model.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Model class with the given name.
            </summary>
            <param name="name">The name of this model.</param>
        </member>
        <member name="M:Sonnet.Model.Clear">
            <summary>
            Clears the objective and all constraints of this model.
            </summary>
        </member>
        <member name="M:Sonnet.Model.ToString(System.Collections.Generic.IEnumerable{Sonnet.Variable})">
            <summary>
            Returns a System.String that represents the current Model, given the set of variables,
            This includes the name of the model, all variables, the objective and all constraints.
            </summary>
            <param name="variables">The set of variables.</param>
            <returns>A string that represents the current Model.</returns>
        </member>
        <member name="M:Sonnet.Model.ToString">
            <summary>
            Returns a System.String that represents the current Model.
            This includes the name of the model, all variables, the objective and all constraints.
            Note, this method iterates over all constraints (!) to build the set of variables in use.
            </summary>
            <returns>A string that represents the current Model.</returns>
        </member>
        <member name="M:Sonnet.Model.Add(System.String,Sonnet.Constraint)">
            <summary>
            Adds a reference to the given constraint to this model, and sets its name.
            </summary>
            <param name="con">The constraint to be added.</param>
            <param name="name">The name of the constraint within this model. Null existing con name.</param>
            <returns>The given constraint.</returns>
        </member>
        <member name="M:Sonnet.Model.Add(Sonnet.Constraint)">
            <summary>
            Adds a reference to the given constraint to this model.
            </summary>
            <param name="con">The constraint to be added.</param>
            <returns>The given constraint.</returns>
        </member>
        <member name="M:Sonnet.Model.Add(System.Collections.IEnumerable)">
            <summary>
            Adds references to the given constraints to this model.
            </summary>
            <param name="constraints">The constraints to be added.</param>
        </member>
        <member name="M:Sonnet.Model.Contains(Sonnet.Constraint)">
            <summary>
            Determine whether this constraint was added to this model.
            </summary>
            <param name="c">The constraint to look for.</param>
            <returns>True iff this constraint is part of this model.</returns>
        </member>
        <member name="M:Sonnet.Model.GetConstraint(System.String)">
            <summary>
            Returns the first constraint with a Name that Equals the given name.
            </summary>
            <param name="name">The name to look for.</param>
            <returns>The first constraint with a Name that Equals the given name, or null if not found.</returns>
        </member>
        <member name="M:Sonnet.Model.New(System.String)">
            <summary>
            Creates a new model from the given file.
            Supported file extensions: .mps only.
            </summary>
            <param name="fileName">The mps file to be imported.</param>
            <returns>The new model, or null if an error occurred.</returns>
        </member>
        <member name="M:Sonnet.Model.New(System.String,Sonnet.Variable[]@)">
            <summary>
            Creates a new model from the given file.
            Supported file extensions: .mps only.
            </summary>
            <param name="fileName">The mps file to be imported.</param>
            <param name="variables">The full array of variables created for this new model.</param>
            <returns>The new model, or null if an error occurred.</returns>
        </member>
        <member name="M:Sonnet.Model.Export(System.String)">
            <summary>
            Exports this model to file.
            Support file extensions: .sonnet only.
            This method simply calls Model.ToString() and writes the output to file.
            To export to different formats, use the Solver.
            </summary>
            <param name="filename">The sonnet file to be exported to.</param>
        </member>
        <member name="M:Sonnet.Model.GetVariables">
            <summary>
            Generate a full list of all used variable from the objective and constraints.
            This is very expensive to call.
            </summary>
            <returns>The list of variables used in the objective and constraints.</returns>
        </member>
        <member name="P:Sonnet.Model.Objective">
            <summary>
            Gets or sets the objective of this model.
            Solvers are updated accordingly.
            Objective must be not-null.
            </summary>
        </member>
        <member name="P:Sonnet.Model.ObjectiveSense">
            <summary>
            Gets or sets the objective sense (Max/Min) of this model.
            Solvers are updated accordingly.
            </summary>
        </member>
        <member name="P:Sonnet.Model.Infinity">
            <summary>
            Get the Infinity value
            </summary>
        </member>
        <member name="P:Sonnet.Model.Constraints">
            <summary>
            Gets the constraints of this model.
            Use model.Add(..) to add constraints.
            </summary>
        </member>
        <member name="P:Sonnet.Model.NumberOfConstraints">
            <summary>
            Gets the number of constraints of this model.
            </summary>
        </member>
        <member name="P:Sonnet.Model.Version">
            <summary>
            Gets the Version number of this assembly
            </summary>
        </member>
        <member name="T:Sonnet.Extensions">
            <summary>
            Provides a set of static methods for creating expressions.
            </summary>
        </member>
        <member name="M:Sonnet.Extensions.Sum(System.Collections.Generic.IEnumerable{Sonnet.Expression})">
            <summary>
            Returns a new expression that is the sum of the given expressions.
            </summary>
            <param name="expressions">The expressions to be summed up.</param>
            <returns>New expression that is the sum of the given expressions.</returns>
        </member>
        <member name="M:Sonnet.Extensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Sonnet.Variable})">
            <summary>
            Computes an expression which is the sum of the sequence of Variables that are obtained
            by invoking a transform function on each element of the input sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence that is used to calculate a sum.</param>
            <param name="selector">A transform function to apply to each element which returns a Variable.</param>
            <returns>The sum of the projected variables.</returns>
        </member>
        <member name="M:Sonnet.Extensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Sonnet.Expression})">
            <summary>
            Computes an expression which is the sum of the sequence of Expressions that are obtained
            by invoking a transform function on each element of the input sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence that is used to calculate a sum.</param>
            <param name="selector">A transform function to apply to each element which returns an Expression.</param>
            <returns>The sum of the projected variables.</returns>
        </member>
        <member name="M:Sonnet.Extensions.Sum``1(System.Collections.Generic.IDictionary{``0,Sonnet.Variable})">
            <summary>
            Returns a new expression that is the sum of the given variables.
            </summary>
            <typeparam name="TKey">This type is ignored.</typeparam>
            <param name="dictionary">The dictionary with variables to be summed up.</param>
            <returns>New expression that is the sum of the given variables.</returns>
        </member>
        <member name="M:Sonnet.Extensions.Sum(System.Collections.IEnumerable)">
            <summary>
            Returns a new expression that is the sum of the given expressions.
            </summary>
            <param name="expressions">The expressions to be summed up.</param>
            <returns>New expression that is the sum of the given expressions.</returns>
        </member>
        <member name="M:Sonnet.Extensions.Sum(System.Collections.Generic.IEnumerable{Sonnet.Variable})">
            <summary>
            Returns a new expression that is the sum of the given variables.
            </summary>
            <param name="variables">The variables to be summed up.</param>
            <returns>New expression that is the sum of the given variables.</returns>
        </member>
        <member name="M:Sonnet.Extensions.ScalarProduct(System.Collections.Generic.IList{Sonnet.Variable},System.Double[])">
            <summary>
            Returns an expression that is the scalar product of the coefficients and variables: 
              sum_i { coefs_i * variables_i }
            Note that the number of coefficients and variables must be equal.
            </summary>
            <param name="variables">The variables</param>
            <param name="coefs">The array of coefficients</param>
            <returns>New expression that is the scalar product of the coefficients and variables.</returns>
        </member>
        <member name="M:Sonnet.Extensions.ScalarProduct(Sonnet.Variable[],System.Double[])">
            <summary>
            Returns an expression that is the scalar product of the coefficients and variables: 
              sum_i { coefs_i * variables_i }
            Note that the number of coefficients and variables must be equal.
            </summary>
            <param name="variables">The variables.</param>
            <param name="coefs">The array of coefficients.</param>
            <returns>New expression that is the scalar product of the coefficients and variables.</returns>
        </member>
        <member name="M:Sonnet.Extensions.ScalarProduct(System.Collections.Generic.IEnumerable{Sonnet.Variable},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns an expression that is the scalar product of the coefficients and variables: 
              sum_i { coefs_i * variables_i }
            Note that the number of coefficients and variables must be equal.
            </summary>
            <param name="variables">The variables.</param>
            <param name="coefs">The array of coefficients.</param>
            <returns>New expression that is the scalar product of the coefficients and variables.</returns>
        </member>
        <member name="T:Sonnet.Expression">
            <summary>
            The class Expression is an important building block in the building of a Model.
            An Expression consists of a constant (double) and an array of variables with their coefficients.
            Many overloaded operators exists for expressions. In principle, these operators 
            return *new* objects (Expressions or Constraints), with all coefficients copied.
            On the other hand, methods exist for manipulating the current expression.
            For example, the overloaded + operator returns copy of lhs + rhs:
              tmp = exp1 + exp2 + exp3;
            performs  
            	((copy exp1, add exp2), copy result (exp1 and exp2), add exp3)
            thus performing n1 + n2 + n1 + n2 + n3 operations in total.
            More efficient is
              tmp.Add(exp1); tmp.Add(exp2); tmp.Add(exp3);
            or equivalently 
              tmp.Add(exp1).Add(exp2).Add(exp3);
            which performs only n1 + n2 + n3 operations.
            </summary>
        </member>
        <member name="M:Sonnet.Expression.#ctor">
            <summary>
            Constructor of empty expression (constant = 0)
            </summary>
        </member>
        <member name="M:Sonnet.Expression.#ctor(System.Double)">
            <summary>
            Constructor of new expression with only the given constrant
            </summary>
            <param name="constant">Constant to use</param>
        </member>
        <member name="M:Sonnet.Expression.#ctor(Sonnet.Variable)">
            <summary>
            Constructor of new expression with one term: 1 * variable
            </summary>
            <param name="variable">Variable to use</param>
        </member>
        <member name="M:Sonnet.Expression.#ctor(System.Double,Sonnet.Variable)">
            <summary>
            Constructor of new expression with one term: coef * variable
            </summary>
            <param name="coef">Multiplication coefficient</param>
            <param name="variable">Variable to use</param>
        </member>
        <member name="M:Sonnet.Expression.#ctor(System.Double,Sonnet.Expression)">
            <summary>
            Constructor copies the given expression and multiplies all coefficients and constant with the given multiplier.
            </summary>
            <param name="multiplier">Multiplier to use</param>
            <param name="expr">Expression to copy and multiply</param>
        </member>
        <member name="M:Sonnet.Expression.#ctor(Sonnet.Expression)">
            <summary>
            Constructor that copies the given expression.
            </summary>
            <param name="expr">Expression to copy</param>
        </member>
        <member name="M:Sonnet.Expression.Clear">
            <summary>
            Removes all coefficients from this expression and set the constant to 0.
            </summary>
        </member>
        <member name="M:Sonnet.Expression.Equals(Sonnet.Expression)">
            <summary>
            Determines whether the specified Expression is equal to the current Expression.
            Note, this expression and the given expression are not necessarily assembled.
            Therefore, for example, the expression (x + x) not "Equals" (2 * x).
            This has nothing to do with equality (EQ) constraints.
            </summary>
            <param name="expr">The Expression to compare with the current Expression.</param>
            <returns>true iff the given expression has the same constant and all coefficients and variables as the current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Equals(System.Object)">
            <summary>
             Determines whether the specified object is equal to the current Expression.
            </summary>
            <param name="obj">The object to compare with the current Expression.</param>
            <returns>True iff the given object is an Expression and is equal to the current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.GetHashCode">
            <summary>
            Serves as a hash function for the current Expression, base on the constant, coefficients and variables.
            </summary>
            <returns>A hash code for the current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.ToString">
            <summary>
            Returns a System.String that represents the current Expression.
            </summary>
            <returns>A System.String that represents the current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Add(System.Double,Sonnet.Variable)">
            <summary>
            Adds the variable with the given coefficient to the current Expression.
            </summary>
            <param name="coef">The coefficient to be added.</param>
            <param name="variable">The Variable to be added with the coefficient.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Add(System.Double)">
            <summary>
            Adds the given constant to the constant of the current Expression.
            </summary>
            <param name="constant">The constant value to be added.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Add(Sonnet.Variable)">
            <summary>
            Adds the given variable with coefficient 1.0 to the current Expression.
            </summary>
            <param name="variable">The Variable to be added.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Add(Sonnet.Expression)">
            <summary>
            Adds the constant and a copy of the coefficients and variables of the given Expression to the current Expression.
            Cannot be used recursively.
            </summary>
            <param name="expr">The expression to be added.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Add(System.Double,Sonnet.Expression)">
            <summary>
            Adds the constant and a copy of the coefficients and variables of the given Expression, multiplied by the given factor
            to the current Expression.
            </summary>
            <param name="factor">The multiplication factor for the given Expression.</param>
            <param name="expr">The expression to be added.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Subtract(System.Double,Sonnet.Variable)">
            <summary>
            Subtracts the given variable with the given coefficient from the current Expression.
            </summary>
            <param name="coef">The coefficient of the variable to be subtracted.</param>
            <param name="variable">The variable to be subtracted with the coefficient</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Subtract(System.Double,Sonnet.Expression)">
            <summary>
            Subtracts the given expression multiplied by the given factor from the current Expression.
            </summary>
            <param name="factor">The multiplication factor for the given expression.</param>
            <param name="expr">The expression to be subtracted.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Subtract(System.Double)">
            <summary>
            Subtracts the given constant from the constant of the current Expression.
            </summary>
            <param name="constant">The value to subtract.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Subtract(Sonnet.Variable)">
            <summary>
            Subtracts the given variable (with coefficient 1.0) from the current Expression.
            </summary>
            <param name="var">The variable to subtract.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Subtract(Sonnet.Expression)">
            <summary>
            Subtracts the given expression from the current Expression
            </summary>
            <param name="expr">The expression to subtract.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Multiply(System.Double)">
            <summary>
            Multiplies the constant and all coefficients of the current Expression by the given multiplier.
            </summary>
            <param name="multiplier">The multiplier to be used.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Divide(System.Double)">
            <summary>
            Divides the constant and all coefficients of the current Expression by the given divider.
            </summary>
            <param name="divider">The divider to be used. Must be non-zero.</param>
            <returns>The updated current Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Remove(Sonnet.Variable)">
            <summary>
            Removes the given variable from the current Expression.
            Note: This method reorders the coefficients.
            </summary>
            <param name="var">The variable to be removed.</param>
            <returns>The sum of all coefficients of the given variable before removing.</returns>
        </member>
        <member name="M:Sonnet.Expression.GetCoefficient(Sonnet.Variable)">
            <summary>
            Determines the sum of all coefficients of the given variable.
            Same as Assemble(var);
            </summary>
            <param name="var">The variable involved.</param>
            <returns>The sum of all coefficients of the given variable.</returns>
        </member>
        <member name="M:Sonnet.Expression.SetCoefficient(Sonnet.Variable,System.Double)">
            <summary>
            Sets the overall coefficient of the given variable to the given value.
            </summary>
            <param name="var">The variable to be used.</param>
            <param name="value">The new coefficient for the given variable.</param>
            <returns>The sum of all *old* coefficients of the given variable.</returns>
        </member>
        <member name="M:Sonnet.Expression.Assemble(Sonnet.Variable)">
            <summary>
            Determines the sum of all coefficients of the given variable.
            </summary>
            <param name="var">The variable to be used.</param>
            <returns>The sum of all coefficients of the given variable.</returns>
        </member>
        <member name="M:Sonnet.Expression.Assemble">
            <summary>
            Assemble the current Expression.
            After Assembling, all variables will appear only once in the list of coefficients.
            </summary>
        </member>
        <member name="M:Sonnet.Expression.Assign(Sonnet.Expression)">
            <summary>
            Clears the current Expression and then adds the given expression.
            </summary>
            <param name="expr">The expression to be assigned.</param>
            <returns>The updated current Expression, equal to the given Expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Assign(System.Double)">
            <summary>
            Clears the current Expression and sets the given constant.
            </summary>
            <param name="constant">The constant to be assigned.</param>
            <returns>The updated current Expression, equal to the given constant.</returns>
        </member>
        <member name="M:Sonnet.Expression.Level">
            <summary>
            Calculates constant plus the product of all coefficients and the Value in the current solution of their variables.
            </summary>
            <returns>The constant plus the product of all coefficients and the Value in the current solution of their variables.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_LessThanOrEqual(Sonnet.Expression,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "lhs &lt;= rhs".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="rhs">The rigt-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_LessThanOrEqual(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new Constraint "lhs &lt;= c".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="c">The constant.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_LessThanOrEqual(System.Double,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "c &lt;= rhs".
            </summary>
            <param name="c">The constant.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_LessThanOrEqual(Sonnet.Variable,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "x &lt;= rhs".
            </summary>
            <param name="x">The variable.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_LessThanOrEqual(Sonnet.Expression,Sonnet.Variable)">
            <summary>
            Creates a new Constraint "lhs &lt;= x".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="x">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_GreaterThanOrEqual(Sonnet.Expression,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "lhs &gt;= rhs".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_GreaterThanOrEqual(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new Constraint "lhs &gt;= c".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="c">The constant.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_GreaterThanOrEqual(System.Double,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "c &gt;= rhs".
            </summary>
            <param name="c">The constant.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_GreaterThanOrEqual(Sonnet.Variable,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "x &gt;= rhs".
            </summary>
            <param name="x">The variable.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_GreaterThanOrEqual(Sonnet.Expression,Sonnet.Variable)">
            <summary>
            Creates a new Constraint "lhs &gt;= x".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="x">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Equality(Sonnet.Expression,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "lhs == rhs".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Equality(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new Constraint "lhs == c".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="c">The constant.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Equality(System.Double,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "c == rhs".
            </summary>
            <param name="c">The constant.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Equality(Sonnet.Variable,Sonnet.Expression)">
            <summary>
            Creates a new Constraint "x == rhs".
            </summary>
            <param name="x">The variable.</param>
            <param name="rhs">The right-hand-side expression of the new constraint.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Equality(Sonnet.Expression,Sonnet.Variable)">
            <summary>
            Creates a new Constraint "lhs == x".
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="x">The variable.</param>
            <returns>The new constraint.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Inequality(Sonnet.Expression,Sonnet.Expression)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="lhs">The left-hand-side expression.</param>
            <param name="rhs">The right-hand-side expression.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Inequality(Sonnet.Expression,System.Double)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="lhs">The left-hand-side expression.</param>
            <param name="c">The constant.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Inequality(System.Double,Sonnet.Expression)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="c">The constant.</param>
            <param name="rhs">The right-hand-side expression.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Inequality(Sonnet.Variable,Sonnet.Expression)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="x">The variable.</param>
            <param name="rhs">The right-hand-side expression.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Inequality(Sonnet.Expression,Sonnet.Variable)">
            <summary>
            Not supported. Added to prevent error CS0216.
            </summary>
            <param name="lhs">The left-hand-side expression of the new constraint.</param>
            <param name="x">The variable.</param>
            <returns>NotSupportedException</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Addition(System.Double,Sonnet.Expression)">
            <summary>
            Creates a new Expression set to "c + expr"
            </summary>
            <param name="c">The constant.</param>
            <param name="expr">The expression</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Addition(Sonnet.Variable,Sonnet.Expression)">
            <summary>
            Creates a new Expression set to "x + expr"
            </summary>
            <param name="x">The variable.</param>
            <param name="expr">The expression.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Addition(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new Expression set to "expr + c"
            </summary>
            <param name="expr">The expression.</param>
            <param name="c">The constant to be added.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Addition(Sonnet.Expression,Sonnet.Variable)">
            <summary>
            Creates a new Expression set to "expr + x"
            </summary>
            <param name="expr">The expression.</param>
            <param name="x">The variable to be added.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Addition(Sonnet.Expression,Sonnet.Expression)">
            <summary>
            Creates a new Expression set to "expr1 + expr2"
            </summary>
            <param name="expr1">The left expression</param>
            <param name="expr2">The right expression</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Subtraction(System.Double,Sonnet.Expression)">
            <summary>
            Creates a new Expression set to "c - expr"
            </summary>
            <param name="c">The constant to be used.</param>
            <param name="expr">The expression.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Subtraction(Sonnet.Variable,Sonnet.Expression)">
            <summary>
            Creates a new Expression set to "x - expr"
            </summary>
            <param name="x">The variable.</param>
            <param name="expr">The expression.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Subtraction(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new Expression set to "expr - c"
            </summary>
            <param name="expr">The expression.</param>
            <param name="c">The constant to be subtracted.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Subtraction(Sonnet.Expression,Sonnet.Variable)">
            <summary>
            Creates a new Expression set to "expr - x"
            </summary>
            <param name="expr">The expression.</param>
            <param name="x">The variable to be subtracted.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Subtraction(Sonnet.Expression,Sonnet.Expression)">
            <summary>
            Creates a new Expression set to "expr1 - expr2"
            </summary>
            <param name="expr1">The left expression.</param>
            <param name="expr2">The right expression.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Multiply(System.Double,Sonnet.Expression)">
            <summary>
            Creates a new expression set to "f * expr".
            The multiplication factor f is applied to the constant and coefficients in the expression.
            </summary>
            <param name="f">The multiplication factor.</param>
            <param name="expr">The expression.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Multiply(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new expression set to "expr * f" ( = "f * expr").
            The multiplication factor f is applied to the constant and coefficients in the expression.
            </summary>
            <param name="expr">The expression.</param>
            <param name="f">The multiplication factor.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.op_Division(Sonnet.Expression,System.Double)">
            <summary>
            Creates a new expression set to "expr / d".,
            The constant and coefficients of the given expression are all divided by d.
            </summary>
            <param name="expr">The expression.</param>
            <param name="d">The divider to be used. Must be non-zero.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.Sum(System.Collections.Generic.IEnumerable{Sonnet.Expression})">
            <summary>
            Returns a new expression that is the sum of the given expressions
            </summary>
            <param name="expressions">The expressions to be summed up.</param>
            <returns>A new expression that is the sum of the given expressions.</returns>
        </member>
        <member name="M:Sonnet.Expression.Sum(System.Collections.Generic.IEnumerable{Sonnet.Variable})">
            <summary>
            Returns a new expression that is the sum of the given variables.
            </summary>
            <param name="variables">The variables to be summed up.</param>
            <returns>A new expression that is the sum of the given variables.</returns>
        </member>
        <member name="M:Sonnet.Expression.ScalarProduct(System.Double[],Sonnet.Variable[])">
            <summary>
            Returns an expression that is the scalar product of the array of coefficients and array of variables: 
              sum_i { coefs_i * variables_i }
            Note that the number of coefficients and variables must be equal.
            </summary>
            <param name="coefs">The coefficients to be used.</param>
            <param name="variables">The variables to be used.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="M:Sonnet.Expression.ScalarProduct(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{Sonnet.Variable})">
            <summary>
            Returns an expression that is the scalar product of the coefficients and variables: 
              sum_i { coefs_i * variables_i }
            Note that the number of coefficients and variables must be equal.
            </summary>
            <param name="coefs">The coefficients to be used.</param>
            <param name="variables">The variables to be used.</param>
            <returns>The new expression.</returns>
        </member>
        <member name="P:Sonnet.Expression.Coefficients">
            <summary>
            Gets the vector of coefficients and variables of the current Expression.
            </summary>
        </member>
        <member name="P:Sonnet.Expression.Constant">
            <summary>
            Gets the constant of the current Expression.
            </summary>
        </member>
        <member name="P:Sonnet.Expression.NumberOfCoefficients">
            <summary>
            Returns the number of coefficients of the current Expression.
            </summary>
        </member>
        <member name="T:Sonnet.RangeConstraint">
            <summary>
            The class RangeConstraint respresents a special type of constraints.
            By definition, a range constraint can be formulated as
             lower &lt;= expression &lt;= upper
            where l and u are constants.
            RangeConstraints can change coefficients of individual variables.
            </summary>
        </member>
        <member name="T:Sonnet.Constraint">
            <summary>
            Class Constraints that can be added to one or more models.
            By definition, a constraint has a left-hand side, a type and a right-hand side.
            </summary>
        </member>
        <member name="M:Sonnet.Constraint.#ctor(Sonnet.Constraint)">
            <summary>
            Initializes a new instance of the Constraint class based on a copy of the given constraint.
            A default name is used.
            </summary>
            <param name="con">The constraint to be copied.</param>
        </member>
        <member name="M:Sonnet.Constraint.#ctor(System.String,Sonnet.Constraint)">
            <summary>
            Initializes a new instance of the Constraint class based on a copy of the given constraint,
            but with the given name.
            </summary>
            <param name="name">The name for the new constraint.</param>
            <param name="con">The constraint to be copied.</param>
        </member>
        <member name="M:Sonnet.Constraint.#ctor(Sonnet.Expression,Sonnet.ConstraintType,Sonnet.Expression)">
            <summary>
            Initializes a new instance of the Constraint class with the default name, 
            of the given type with the given left and right-hand side expressions.
            The given expressions are copied, and therefore are no longer needed after this constructor is called.
            </summary>
            <param name="lhs">The left-hand side expression of the constraint.</param>
            <param name="type">The type of the constraint.</param>
            <param name="rhs">The right-hand side expression of the consrtaint.</param>
        </member>
        <member name="M:Sonnet.Constraint.#ctor(System.String,Sonnet.Expression,Sonnet.ConstraintType,Sonnet.Expression)">
            <summary>
            Initializes a new instance of the Constraint class with the given name, 
            of the given type with the given left and right-hand side expressions.
            The given expressions are copied, and therefore are no longer needed after this constructor is called.
            </summary>
            <param name="name">The name for the new constraint.</param>
            <param name="lhs">The left-hand side expression of the constraint.</param>
            <param name="type">The type of the constraint.</param>
            <param name="rhs">The right-hand side expression of the consrtaint.</param>
        </member>
        <member name="M:Sonnet.Constraint.Clear">
            <summary>
            Clear this constraint by clearing its expressions.
            </summary>
        </member>
        <member name="M:Sonnet.Constraint.ToString">
            <summary>
            Returns a System.String that represents the current Constraint.
            </summary>
            <returns>A System.String that represents the current Constraint.</returns>
        </member>
        <member name="M:Sonnet.Constraint.ToLevelString">
            <summary>
            Returns a string that represents the value of this instance using the Level of the expressions.
            </summary>
            <returns>A string representation of this instance using the Level.</returns>
        </member>
        <member name="M:Sonnet.Constraint.op_LessThanOrEqual(Sonnet.Constraint,System.Double)">
            <summary>
            Creates a new RangeConstraint "l &lt;= expr &lt;= u"
            where l is the left-hand side constant of the given constraint,
            expr is the right-hand side of the constraint and u is the given upper bound.
            Note that this can be used as
              RangeConstraint rcon = 2 &lt;= x + y &lt;= 10;
            because (2 &lt;= x + y) is first made into a constraint.
            </summary>
            <param name="con">The &lt;= constraint that will be used for its right-hand side expression. The left-hand side expressin must not contain any variables.</param>
            <param name="upper">The upper bound of the new range constraint.</param>
            <returns>The new range constraint.</returns>
        </member>
        <member name="M:Sonnet.Constraint.op_GreaterThanOrEqual(Sonnet.Constraint,System.Double)">
            <summary>
            Throws an exception: Range constraints can only be &lt;= constraints.
            </summary>
            <param name="con">The constraint.</param>
            <param name="rhs">The bound.</param>
            <returns>A SonnetException</returns>
        </member>
        <member name="M:Sonnet.Constraint.Level">
            <summary>
            Determines the level of the left-hand side expression of this constraint in the current solution.
            </summary>
            <returns>The level of the left-hand side expression of this constraint in the current solution.</returns>
        </member>
        <member name="M:Sonnet.Constraint.IsFeasible">
            <summary>
            Determines whether the current solution is feasible wrt this constraint by checking whether the slack is non-negative.
            </summary>
            <returns>True if this constraint is satisfied; false otherwise.</returns>
        </member>
        <member name="M:Sonnet.Constraint.Slack">
            <summary>
            Determines the slack of this constraint in the current solution. Regardless of the type of constraint, the slack should 
            be non-negative in a feasible solution.
            </summary>
            <returns>The slack of this constraint in the current solution.</returns>
        </member>
        <member name="F:Sonnet.Constraint.numberOfConstraints">
            <summary>
            Counts the global number of constraints. Mainly used for id.
            </summary>
        </member>
        <member name="F:Sonnet.Constraint.expr">
            <summary>
            The (left-hand side) expression of this constraint.
            </summary>
        </member>
        <member name="F:Sonnet.Constraint.rhs">
            <summary>
            The right-hand side expression of this constraint.
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Type">
            <summary>
            Gets the type of this constraint.
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Name">
            <summary>
            Gets or sets the name of this constraint.
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Price">
            <summary>
            Gets the price of this constraint in the current solution.
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Value">
            <summary>
            Gets the value of this constraint in the current solution.
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Enabled">
            <summary>
            Gets or sets whether this constraint is enabled (enforced).
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Lower">
            <summary>
            Gets the lower bound of this constraint. For EQ and GE constraint, this is the right-hand side constant.
            For LE constraints, this is -inf.
            Only RangeConstraints can Set the lower bound.
            </summary>
        </member>
        <member name="P:Sonnet.Constraint.Upper">
            <summary>
            Gets the upper bound of this constraint. For EQ and LE constraint, this is the right-hand side constant.
            For GE constraints, this is +inf.
            Only RangeConstraints can Set the upper bound.
            </summary>
        </member>
        <member name="M:Sonnet.RangeConstraint.#ctor(Sonnet.RangeConstraint)">
            <summary>
            Initializes a new instance of the RangeConstraint class based on a copy of the given constraint.
            A default name is used.
            </summary>
            <param name="rangeConstraint">The range constraint to be copied.</param>
        </member>
        <member name="M:Sonnet.RangeConstraint.#ctor(System.String,Sonnet.RangeConstraint)">
            <summary>
            Initializes a new instance of the RangeConstraint class based on a copy of the given constraint,
            but with the given name.
            </summary>
            <param name="name">The name for the new constraint.</param>
            <param name="rangeConstraint">The range constraint to be copied.</param>
        </member>
        <member name="M:Sonnet.RangeConstraint.#ctor(System.Double,Sonnet.Expression,System.Double)">
            <summary>
            Initializes a new instance of the RangeConstraint class with the default name, 
            and of the form      lower &lt;= expr &lt;= upper
            The given expression is copied, and therefore are no longer needed after this constructor is called.
            </summary>
            <param name="lower">The left-hand side constant of the range constraint.</param>
            <param name="expr">The middle expression of the constraint.</param>
            <param name="upper">The right-hand side constant of the range consrtaint.</param>
        </member>
        <member name="M:Sonnet.RangeConstraint.#ctor(System.String,System.Double,Sonnet.Expression,System.Double)">
            <summary>
            Initializes a new instance of the RangeConstraint class with the given name, 
            and of the form      lower &lt;= expr &lt;= upper
            The given expression is copied, and therefore are no longer needed after this constructor is called.
            </summary>
            <param name="name">The name for the new constraint.</param>
            <param name="lower">The left-hand side constant of the range constraint.</param>
            <param name="expr">The middle expression of the constraint.</param>
            <param name="upper">The right-hand side constant of the range consrtaint.</param>
        </member>
        <member name="M:Sonnet.RangeConstraint.ToString">
            <summary>
            Returns a System.String that represents the current RangeConstraint.
            </summary>
            <returns>A System.String that represents the current RangeConstraint.</returns>
        </member>
        <member name="M:Sonnet.RangeConstraint.ToLevelString">
            <summary>
            Returns a string that represents the value of this instance using the Level of the expressions.
            </summary>
            <returns>A string representation of this instance using the Level.</returns>
        </member>
        <member name="M:Sonnet.RangeConstraint.SetBounds(System.Double,System.Double)">
            <summary>
            Sets both the constant lower and upper bound of this range constraint.
            Note that range constaints can only be '&lt;=' constraints.
            </summary>
            <param name="lower">The lower bound.</param>
            <param name="upper">The upper bound.</param>
        </member>
        <member name="M:Sonnet.RangeConstraint.GetCoefficient(Sonnet.Variable)">
            <summary>
            Retrieve the overall coefficient of the given variable in the expression part of this range constraint.
            </summary>
            <param name="var">The variable for which to retrieve the coefficient.</param>
            <returns>The overall coefficient of the given variable.</returns>
        </member>
        <member name="M:Sonnet.RangeConstraint.Slack">
            <summary>
            Determines the slack compared to the upper bound (only) of this range constraint in the current solution. 
            The slack should be non-negative in a feasible solution.
            </summary>
            <returns>The slack compared to the upper bound of this constraint in the current solution.</returns>
        </member>
        <member name="P:Sonnet.RangeConstraint.Lower">
            <summary>
            Gets or sets the constant lower (left-hand-side) bound of this range constraint. 
            Note that range constaints can only be '&lt;=' constraints.
            </summary>
        </member>
        <member name="P:Sonnet.RangeConstraint.Upper">
            <summary>
            Gets or sets the constant upper (right-hand-side) bound of this range constraint.
            Note that range constaints can only be '&lt;=' constraints.
            </summary>
        </member>
        <member name="T:Sonnet.ConstraintType">
            <summary>
            Specifies the types of constraints: less-or-equal (LE), greater-or-equal (GE) or equal (EQ)
            </summary>
        </member>
        <member name="F:Sonnet.ConstraintType.LE">
            <summary>
            Less-or-equal
            </summary>
        </member>
        <member name="F:Sonnet.ConstraintType.GE">
            <summary>
            Greater-or-equal
            </summary>
        </member>
        <member name="F:Sonnet.ConstraintType.EQ">
            <summary>
            Equal
            </summary>
        </member>
        <member name="T:Sonnet.SonnetMessages">
            <summary>
            The class SonnetMessages holds the specifications for the different types of messages.
            The message types are matched to COIN message numbers, in particular 
            Debug (0), Information (1000), Warning (3000) and Error (6000).
            The Source is hardcoded to 'SNNT'.
            </summary>
        </member>
        <member name="T:Sonnet.SonnetLog">
            <summary>
            Singleton with standard MessaHandler (write to Console) and use the defined SonnetMessages types
            Debug, Information, Warning and Error.
            </summary>
        </member>
        <member name="M:Sonnet.SonnetLog.#ctor">
            <summary>
            Protected constructor 
            </summary>
        </member>
        <member name="M:Sonnet.SonnetLog.PassToSolver(COIN.OsiSolverInterface)">
            <summary>
            Pass this message handler to the given solver.
            </summary>
            <param name="solver">The solver to pass this message handler to.</param>
        </member>
        <member name="M:Sonnet.SonnetLog.PassToCoinMpsIO(COIN.CoinMpsIO)">
            <summary>
            Pass this message handler to the given CoinMpsIO instance.
            </summary>
            <param name="obj">The CoinMpsIO instance to pass this message handler to.</param>
        </member>
        <member name="M:Sonnet.SonnetLog.PassToCoinLpIO(COIN.CoinLpIO)">
            <summary>
            Pass this message handler to the given CoinLpIO instance.
            </summary>
            <param name="obj">The CoinLpIO instance to pass this message handler to.</param>
        </member>
        <member name="M:Sonnet.SonnetLog.Debug(System.String)">
            <summary>
            Write a Debug message (log level 0) to this message handler.
            </summary>
            <param name="message">The message to log.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Write a formatted Debug message (log level 0) to this message handler.
            See string.Format(..) : 
            Replaces the format item in a specified string with the string representation
             of a corresponding object in a specified array.
            </summary>
            <param name="format">A composite format string.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.Info(System.String)">
            <summary>
            Write an Information message (log level 1000) to this message handler.
            </summary>
            <param name="message">The message to log.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Write a formatted Information message (log level 1000) to this message handler.
            See string.Format(..) : 
            Replaces the format item in a specified string with the string representation
             of a corresponding object in a specified array.
            </summary>
            <param name="format">A composite format string.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.Warn(System.String)">
            <summary>
            Write a Warning message (log level 3000) to this message handler.
            </summary>
            <param name="message">The message to log.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Write a formatted Warning message (log level 3000) to this message handler.
            See string.Format(..) : 
            Replaces the format item in a specified string with the string representation
             of a corresponding object in a specified array.
            </summary>
            <param name="format">A composite format string.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.Error(System.String)">
            <summary>
            Write an Error message (log level 6000) to this message handler.
            </summary>
            <param name="message">The message to log.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="M:Sonnet.SonnetLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Write a formatted Error message (log level 6000) to this message handler.
            See string.Format(..) : 
            Replaces the format item in a specified string with the string representation
             of a corresponding object in a specified array.
            </summary>
            <param name="format">A composite format string.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <returns>The logged message.</returns>
        </member>
        <member name="P:Sonnet.SonnetLog.Default">
            <summary>
            Returns the singleton SonnetLog
            </summary>
        </member>
        <member name="P:Sonnet.SonnetLog.LogLevel">
            <summary>
            Gets or sets the logLevel of this message handler. See COIN documentation.
            </summary>
        </member>
    </members>
</doc>
